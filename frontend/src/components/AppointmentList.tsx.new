import { 
  Card, 
  CardContent, 
  Typography, 
  Box, 
  Chip, 
  IconButton, 
  Button, 
  Dialog, 
  DialogTitle, 
  DialogContent, 
  DialogActions,
  Snackbar,
  Alert,
  TextField,
  MenuItem,
  Paper,
  Drawer,
  Tooltip,
  Pagination,
  Grid as MuiGrid,
  Switch,
  FormControlLabel,
  type ChipProps,
  Avatar,
  InputAdornment
} from '@mui/material';
import {
  AccessTime as AccessTimeIcon,
  ViewList as ViewListIcon,
  GridView as GridViewIcon,
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  Email as EmailIcon,
  Phone as PhoneIcon,
  Close as CloseIcon,
  AccountCircle as AccountCircleIcon,
  ArrowUpward as ArrowUpwardIcon,
  ArrowDownward as ArrowDownwardIcon,
  Search as SearchIcon,
  CalendarToday as CalendarIcon,
} from '@mui/icons-material';
import { useState, useEffect, useCallback, useMemo } from 'react';
import { format, isToday } from 'date-fns';
import type { ChangeEvent, MouseEvent } from 'react';
import type { Appointment, AppointmentStatus, SocialWork } from '../types/appointment';
import { appointmentService } from '../services/appointmentService';

import type { BaseAppointment } from '../types/appointment';
type FormData = BaseAppointment;

const initialFormState: FormData = {
  clientName: '',
  date: '',
  time: '',
  status: 'pending',
  socialWork: 'CONSULTA PARTICULAR',
  phone: '',
  email: '',
  description: '',
  attended: false
};

const socialWorkOptions: SocialWork[] = [
  'INSSSEP',
  'Swiss Medical',
  'OSDE',
  'Galeno',
  'CONSULTA PARTICULAR'
];

const statusOptions: { value: AppointmentStatus; label: string }[] = [
  { value: 'pending', label: 'Pendiente' },
  { value: 'confirmed', label: 'Confirmada' },
  { value: 'cancelled', label: 'Cancelada' }
];

const getStatusColor = (status: AppointmentStatus): ChipProps['color'] => {
  switch (status) {
    case 'pending':
      return 'warning';
    case 'confirmed':
      return 'success';
    case 'cancelled':
      return 'error';
    default:
      return 'default';
  }
};

const getStatusLabel = (status: AppointmentStatus) => {
  switch (status) {
    case 'pending': return 'Pendiente';
    case 'confirmed': return 'Confirmada';
    case 'cancelled': return 'Cancelada';
    default: return status;
  }
};

const ITEMS_PER_PAGE = 6;

const AppointmentList: React.FC = () => {
  // Estados
  const [appointments, setAppointments] = useState<Appointment[]>([]);
  const [selectedAppointment, setSelectedAppointment] = useState<Appointment | null>(null);
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [openDialog, setOpenDialog] = useState(false);
  const [deleteConfirmOpen, setDeleteConfirmOpen] = useState(false);
  const [editingAppointment, setEditingAppointment] = useState<Appointment | null>(null);
  const [formData, setFormData] = useState<FormData>(initialFormState);
  const [snackbar, setSnackbar] = useState<{
    open: boolean;
    message: string;
    severity: 'success' | 'error';
  }>({
    open: false,
    message: '',
    severity: 'success'
  });
  
  // Estados para filtrado y paginación
  const [searchQuery, setSearchQuery] = useState('');
  const [dateFilter, setDateFilter] = useState('');
  const [page, setPage] = useState(1);
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');

  // Manejadores de eventos para filtros
  const handleSearchChange = (event: ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(event.target.value);
    setPage(1); // Reset a la primera página cuando se busca
  };

  const handleDateFilterChange = (event: ChangeEvent<HTMLInputElement>) => {
    setDateFilter(event.target.value);
    setPage(1); // Reset a la primera página cuando se filtra
  };

  const handlePageChange = (_event: React.ChangeEvent<unknown>, value: number) => {
    setPage(value);
  };

  const handleViewModeChange = () => {
    setViewMode(prev => prev === 'grid' ? 'list' : 'grid');
  };

  // Filtrar y ordenar las citas
  const filteredAppointments = useMemo(() => {
    return appointments
      .filter(appointment => {
        const matchesSearch = !searchQuery || 
          appointment.clientName.toLowerCase().includes(searchQuery.toLowerCase()) ||
          appointment.phone.includes(searchQuery);
        
        const matchesDate = !dateFilter || appointment.date === dateFilter;
        
        return matchesSearch && matchesDate;
      })
      .sort((a, b) => {
        // Ordenar por fecha más reciente primero
        return new Date(b.date).getTime() - new Date(a.date).getTime();
      });
  }, [appointments, searchQuery, dateFilter]);

  // Calcular el número total de páginas
  const totalPages = Math.ceil(filteredAppointments.length / ITEMS_PER_PAGE);
  
  // Obtener las citas para la página actual
  const paginatedAppointments = filteredAppointments.slice(
    (page - 1) * ITEMS_PER_PAGE,
    page * ITEMS_PER_PAGE
  );

  // Resto de la funcionalidad existente...
  const handleCloseSnackbar = () => {
    setSnackbar(prev => ({ ...prev, open: false }));
  };

  const loadAppointments = useCallback(async () => {
    try {
      const data = await appointmentService.getAll();
      setAppointments(data);
    } catch {
      setSnackbar({
        open: true,
        message: 'Error al cargar las citas',
        severity: 'error'
      });
    }
  }, []);

  useEffect(() => {
    loadAppointments();
  }, [loadAppointments]);

  const handleFormChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    try {
      if (editingAppointment) {
        await appointmentService.update(editingAppointment._id, formData);
        setSnackbar({
          open: true,
          message: 'Cita actualizada correctamente',
          severity: 'success'
        });
      } else {
        await appointmentService.create(formData);
        setSnackbar({
          open: true,
          message: 'Cita creada correctamente',
          severity: 'success'
        });
      }
      setOpenDialog(false);
      setEditingAppointment(null);
      setFormData(initialFormState);
      await loadAppointments();
    } catch {
      setSnackbar({
        open: true,
        message: editingAppointment 
          ? 'Error al actualizar la cita'
          : 'Error al crear la cita',
        severity: 'error'
      });
    }
  };

  const handleEditClick = (appointment: Appointment) => {
    setEditingAppointment(appointment);
    setFormData({
      clientName: appointment.clientName,
      date: appointment.date,
      time: appointment.time,
      status: appointment.status,
      socialWork: appointment.socialWork,
      phone: appointment.phone,
      email: appointment.email || '',
      description: appointment.description || ''
    });
    setOpenDialog(true);
  };

  const handleDeleteClick = (appointmentId: string) => {
    setDeleteConfirmOpen(true);
    setEditingAppointment(appointments.find(a => a._id === appointmentId) || null);
  };

  const handleDelete = async () => {
    if (!editingAppointment) return;

    try {
      await appointmentService.delete(editingAppointment._id);
      setSnackbar({
        open: true,
        message: 'Cita eliminada correctamente',
        severity: 'success'
      });
      await loadAppointments();
    } catch {
      setSnackbar({
        open: true,
        message: 'Error al eliminar la cita',
        severity: 'error'
      });
    } finally {
      setDeleteConfirmOpen(false);
      setEditingAppointment(null);
    }
  };

  const handleAppointmentClick = (appointment: Appointment) => {
    setSelectedAppointment(appointment);
    setDrawerOpen(true);
  };

  const handleAttendedChange = async (appointmentId: string, attended: boolean, event?: React.SyntheticEvent) => {
    if (event) {
      event.stopPropagation();
    }

    try {
      const updateData = {
        attended,
        status: attended ? 'confirmed' as AppointmentStatus : 'pending' as AppointmentStatus
      };

      await appointmentService.update(appointmentId, updateData);
      
      setAppointments(prev => prev.map(app => 
        app._id === appointmentId ? { ...app, ...updateData } : app
      ));

      if (selectedAppointment && selectedAppointment._id === appointmentId) {
        setSelectedAppointment(prev => prev ? { ...prev, ...updateData } : prev);
      }

      setSnackbar({
        open: true,
        message: `Asistencia ${attended ? 'marcada' : 'desmarcada'} correctamente`,
        severity: 'success'
      });
    } catch {
      setSnackbar({
        open: true,
        message: 'Error al actualizar el estado de asistencia',
        severity: 'error'
      });
    }
  };

  const handleDescriptionChange = (appointmentId: string, newDescription: string) => {
    const appointment = appointments.find(a => a._id === appointmentId);
    if (!appointment) return;

    setAppointments(prev => prev.map(app => 
      app._id === appointmentId ? { ...app, description: newDescription } : app
    ));

    if (selectedAppointment && selectedAppointment._id === appointmentId) {
      setSelectedAppointment(prev => prev ? { ...prev, description: newDescription } : prev);
    }

    appointmentService.update(appointmentId, { description: newDescription })
      .catch(() => {
        setSnackbar({
          open: true,
          message: 'Error al guardar la descripción',
          severity: 'error'
        });
      });
  };

  const AppointmentCard = ({ appointment }: { appointment: Appointment }) => (
    <Card 
      sx={{ 
        cursor: 'pointer',
        '&:hover': { boxShadow: 6 },
        display: 'flex',
        flexDirection: viewMode === 'grid' ? 'column' : 'row',
        height: viewMode === 'grid' ? 'auto' : '100px'
      }}
      onClick={() => handleAppointmentClick(appointment)}
    >
      <CardContent sx={{ 
        flex: 1,
        display: 'flex',
        flexDirection: viewMode === 'grid' ? 'column' : 'row',
        alignItems: viewMode === 'grid' ? 'flex-start' : 'center',
        gap: 2,
        py: viewMode === 'grid' ? 2 : 1,
        "&:last-child": { pb: viewMode === 'grid' ? 2 : 1 }
      }}>
        <Avatar 
          sx={{ 
            width: viewMode === 'grid' ? 60 : 40,
            height: viewMode === 'grid' ? 60 : 40,
            bgcolor: appointment.attended ? 'success.main' : 'primary.main'
          }}
        >
          {appointment.clientName.split(' ').map(name => name[0]).join('').toUpperCase()}
        </Avatar>

        <Box sx={{ 
          flex: viewMode === 'grid' ? 1 : 0.3,
          minWidth: viewMode === 'grid' ? 'auto' : '200px'
        }}>
          <Typography variant="h6" component="div" noWrap>
            {appointment.clientName}
          </Typography>
          <Typography color="text.secondary" variant={viewMode === 'grid' ? 'body1' : 'body2'}>
            {format(new Date(`${appointment.date}T00:00:00`), 'dd/MM/yyyy')} - {appointment.time}
          </Typography>
        </Box>

        <Box sx={{ 
          flex: viewMode === 'grid' ? 1 : 0.3,
          display: 'flex',
          flexDirection: viewMode === 'grid' ? 'column' : 'row',
          alignItems: viewMode === 'grid' ? 'flex-start' : 'center',
          gap: 1
        }}>
          <Typography color="text.secondary" variant={viewMode === 'grid' ? 'body1' : 'body2'}>
            {appointment.socialWork}
          </Typography>
        </Box>

        <Box sx={{ 
          flex: viewMode === 'grid' ? 1 : 0.4,
          display: 'flex',
          justifyContent: viewMode === 'grid' ? 'flex-start' : 'flex-end',
          alignItems: 'center',
          gap: 2,
          ml: viewMode === 'grid' ? 0 : 'auto'
        }}>
          <FormControlLabel
            control={
              <Switch
                checked={appointment.attended}
                onChange={(e) => {
                  e.stopPropagation();
                  handleAttendedChange(appointment._id, e.target.checked);
                }}
                onClick={(e) => e.stopPropagation()}
                color="success"
                sx={{
                  '& .MuiSwitch-switchBase.Mui-checked': {
                    color: 'success.main',
                    '&:hover': {
                      backgroundColor: 'success.light'
                    },
                  },
                  '& .MuiSwitch-switchBase.Mui-checked + .MuiSwitch-track': {
                    backgroundColor: 'success.main',
                  },
                }}
              />
            }
            label="Asistió"
          />
          <Chip
            label={getStatusLabel(appointment.status)}
            color={getStatusColor(appointment.status)}
            size={viewMode === 'grid' ? 'medium' : 'small'}
          />
        </Box>
      </CardContent>
    </Card>
  );

  return (
    <Box sx={{ p: 3 }}>
      {/* Controles de filtrado */}
      <Box sx={{ mb: 3, display: 'flex', gap: 2, alignItems: 'center' }}>
        <TextField
          size="small"
          label="Buscar por nombre o teléfono"
          value={searchQuery}
          onChange={handleSearchChange}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <SearchIcon />
              </InputAdornment>
            ),
          }}
          sx={{ minWidth: 250 }}
        />
        <TextField
          size="small"
          type="date"
          label="Filtrar por fecha"
          value={dateFilter}
          onChange={handleDateFilterChange}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <CalendarIcon />
              </InputAdornment>
            ),
          }}
          sx={{ minWidth: 200 }}
          InputLabelProps={{ shrink: true }}
        />

        <Box sx={{ display: 'flex', gap: 1, ml: 'auto' }}>
          <Tooltip title={viewMode === 'grid' ? 'Ver como lista' : 'Ver como grid'}>
            <IconButton onClick={handleViewModeChange} color="primary">
              {viewMode === 'grid' ? <ViewListIcon /> : <GridViewIcon />}
            </IconButton>
          </Tooltip>
          <Tooltip title="Nueva cita">
            <IconButton
              onClick={() => {
                setFormData(initialFormState);
                setEditingAppointment(null);
                setOpenDialog(true);
              }}
              color="primary"
            >
              <AddIcon />
            </IconButton>
          </Tooltip>
        </Box>
      </Box>

      {/* Grid de citas */}
      <Box sx={{
        display: viewMode === 'grid' ? 'grid' : 'flex',
        gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))',
        flexDirection: 'column',
        gap: 2
      }}>
        {paginatedAppointments.map(appointment => (
          <AppointmentCard 
            key={appointment._id}
            appointment={appointment}
          />
        ))}
      </Box>

      {/* Paginación */}
      {totalPages > 1 && (
        <Box sx={{ mt: 3, display: 'flex', justifyContent: 'center' }}>
          <Pagination
            count={totalPages}
            page={page}
            onChange={handlePageChange}
            color="primary"
          />
        </Box>
      )}

      {/* Drawer de detalles */}
      <Drawer
        anchor="right"
        open={drawerOpen}
        onClose={() => setDrawerOpen(false)}
        sx={{
          '& .MuiDrawer-paper': { width: 400 }
        }}
      >
        {selectedAppointment && (
          <Box sx={{ p: 3 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 3 }}>
              <Typography variant="h6">Detalles de la cita</Typography>
              <IconButton onClick={() => setDrawerOpen(false)}>
                <CloseIcon />
              </IconButton>
            </Box>

            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
              <Box>
                <Typography variant="subtitle2" gutterBottom>
                  Paciente
                </Typography>
                <Typography variant="h5">
                  {selectedAppointment.clientName}
                </Typography>
              </Box>

              <Box>
                <Typography variant="subtitle2" gutterBottom>
                  Fecha y hora
                </Typography>
                <Typography>
                  {format(new Date(`${selectedAppointment.date}T00:00:00`), 'dd/MM/yyyy')} - {selectedAppointment.time}
                </Typography>
              </Box>

              <Box>
                <Typography variant="subtitle2" gutterBottom>
                  Contacto
                </Typography>
                <Typography>{selectedAppointment.phone}</Typography>
                {selectedAppointment.email && (
                  <Typography>{selectedAppointment.email}</Typography>
                )}
              </Box>

              <Box>
                <Typography variant="subtitle2" gutterBottom>
                  Estado
                </Typography>
                <FormControlLabel
                  control={
                    <Switch
                      checked={selectedAppointment.attended}
                      onChange={(e) => handleAttendedChange(selectedAppointment._id, e.target.checked)}
                      color="success"
                    />
                  }
                  label="Asistió"
                />
                <Chip
                  label={getStatusLabel(selectedAppointment.status)}
                  color={getStatusColor(selectedAppointment.status)}
                  sx={{ ml: 1 }}
                />
              </Box>

              <Box>
                <Typography variant="subtitle2" gutterBottom>
                  Notas
                </Typography>
                <TextField
                  multiline
                  rows={4}
                  fullWidth
                  value={selectedAppointment.description || ''}
                  onChange={(e) => handleDescriptionChange(selectedAppointment._id, e.target.value)}
                  placeholder="Agregar notas..."
                />
              </Box>

              <Box sx={{ display: 'flex', gap: 1 }}>
                <Button
                  variant="outlined"
                  startIcon={<EditIcon />}
                  onClick={() => handleEditClick(selectedAppointment)}
                  fullWidth
                >
                  Editar
                </Button>
                <Button
                  variant="outlined"
                  color="error"
                  startIcon={<DeleteIcon />}
                  onClick={() => handleDeleteClick(selectedAppointment._id)}
                  fullWidth
                >
                  Eliminar
                </Button>
              </Box>
            </Box>
          </Box>
        )}
      </Drawer>

      {/* Diálogos */}
      <Dialog
        open={deleteConfirmOpen}
        onClose={() => setDeleteConfirmOpen(false)}
      >
        <DialogTitle>¿Eliminar cita?</DialogTitle>
        <DialogContent>
          <Typography>
            Esta acción no se puede deshacer. ¿Está seguro que desea eliminar esta cita?
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDeleteConfirmOpen(false)}>
            Cancelar
          </Button>
          <Button
            onClick={handleDelete}
            color="error"
            variant="contained"
          >
            Eliminar
          </Button>
        </DialogActions>
      </Dialog>

      <Dialog
        open={openDialog}
        onClose={() => {
          setOpenDialog(false);
          setEditingAppointment(null);
          setFormData(initialFormState);
        }}
        maxWidth="sm"
        fullWidth
      >
        <form onSubmit={handleSubmit}>
          <DialogTitle>
            {editingAppointment ? 'Editar cita' : 'Nueva cita'}
          </DialogTitle>
          <DialogContent>
            <Box sx={{ mt: 2, display: 'flex', flexDirection: 'column', gap: 2 }}>
              <TextField
                label="Nombre del paciente"
                name="clientName"
                value={formData.clientName}
                onChange={handleFormChange}
                fullWidth
                required
              />
              
              <Box sx={{ display: 'flex', gap: 2 }}>
                <TextField
                  label="Fecha"
                  name="date"
                  type="date"
                  value={formData.date}
                  onChange={handleFormChange}
                  fullWidth
                  required
                  InputLabelProps={{ shrink: true }}
                />
                <TextField
                  label="Hora"
                  name="time"
                  type="time"
                  value={formData.time}
                  onChange={handleFormChange}
                  fullWidth
                  required
                  InputLabelProps={{ shrink: true }}
                />
              </Box>

              <TextField
                select
                label="Obra social"
                name="socialWork"
                value={formData.socialWork}
                onChange={handleFormChange}
                fullWidth
                required
              >
                {socialWorkOptions.map(option => (
                  <MenuItem key={option} value={option}>
                    {option}
                  </MenuItem>
                ))}
              </TextField>

              {editingAppointment && (
                <TextField
                  select
                  label="Estado"
                  name="status"
                  value={formData.status}
                  onChange={handleFormChange}
                  fullWidth
                  required
                >
                  {statusOptions.map(option => (
                    <MenuItem key={option.value} value={option.value}>
                      {option.label}
                    </MenuItem>
                  ))}
                </TextField>
              )}

              <TextField
                label="Teléfono"
                name="phone"
                value={formData.phone}
                onChange={handleFormChange}
                fullWidth
                required
              />

              <TextField
                label="Email"
                name="email"
                type="email"
                value={formData.email}
                onChange={handleFormChange}
                fullWidth
              />

              <TextField
                label="Notas"
                name="description"
                value={formData.description}
                onChange={handleFormChange}
                multiline
                rows={4}
                fullWidth
              />
            </Box>
          </DialogContent>
          <DialogActions>
            <Button
              onClick={() => {
                setOpenDialog(false);
                setEditingAppointment(null);
                setFormData(initialFormState);
              }}
            >
              Cancelar
            </Button>
            <Button
              type="submit"
              variant="contained"
              color="primary"
            >
              {editingAppointment ? 'Guardar cambios' : 'Crear cita'}
            </Button>
          </DialogActions>
        </form>
      </Dialog>

      {/* Snackbar de notificaciones */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
      >
        <Alert
          onClose={handleCloseSnackbar}
          severity={snackbar.severity}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default AppointmentList;
